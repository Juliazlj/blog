---
title: 二叉树的前中后序遍历
date: 2020-12-01
sidebar: 'auto'
categories:
 - 算法
tags:
 - 栈
 - 二叉树
publish: true
---
## 使用递归
### 前序
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if (!root) {
            return;
        }
        res.push(root.val);
        inorder(root.left);
        inorder(root.right);
    }
    inorder(root);
    return res;
};
```
### 中序
```javascript
var inorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if (!root) {
            return;
        }
        inorder(root.left);
        res.push(root.val);
        inorder(root.right);
    }
    inorder(root);
    return res;
};
```
### 后序
```javascript
var postOrderRecur = function(root) {
    const res = [];
    const inorder = (root) => {
        if (!root) {
            return;
        }
        inorder(root.left);
        inorder(root.right);
        res.push(root.val);
    }
    inorder(root);
    return res;
};
```
## 迭代写法
### 前序
前序是 中左右 的顺序，先推入根节点，再把根节点推出栈放到结果里，再推入右节点，再推入左节点，此时栈里面有[右，左]两个节点。
接着继续推出栈里的左节点放到结果里，再推出右节点放到结果里。
```javascript
var preorderTraversal = function(root) {
    if(!root){
        return [];
    }
    const ret = [];
    const stk = [];
    let node = root;
    stk.push(node)
    while(stk.length){
        const curr = stk.pop();
        ret.push(curr.val);
        if(curr.right){
            stk.push(curr.right);
        }
        if(curr.left){
            stk.push(curr.left)
        }
    }
    return ret
};
```
### 中序
中序遍历是 左中右 的顺序，我们可以向左遍历推入左节点直到遍历到树的最左节点，然后依次推出栈，并放到结果里，推出一个就判断有没有右节点，如果有右节点就继续把节点设置为右节点再次循环
```javascript
var inorderTraversal = function(root) {
    let node = root;
    const res = [];
    const stk = [];
    while (node || stk.length) {
        while (node) {
            stk.push(node);
            node = node.left;
        }
        const curr = stk.pop();
        res.push(curr.val);
        if(curr.right){
            node = curr.right;
        }
    }
    return res;
};
```
### 后序
后序的顺序是 左右中 ，和前序 中左右 其实很类似，我们可以拿前序改一改，结果倒过来就是后序的结果了。
```javascript
var postorderTraversal = function(root) {
    if(!root){
        return [];
    }
    const ret = [];
    const stk = [];
    let node = root;
    stk.push(node)
    while(stk.length){
        const curr = stk.pop();
        ret.push(curr.val);
        if(curr.left){
            stk.push(curr.left)
        }
        if(curr.right){
            stk.push(curr.right);
        }
    }
    return ret.reverse();
};
```
